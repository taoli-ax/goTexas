# Project Ace: 德州扑克后端项目 - 8周开发计划

## 1. 项目概述

- **目标:** 构建一个功能完整、技术栈现代化的德州扑克后端系统，并将其部署到GCP，通过GitHub Actions实现CI/CD。
- **时间约束:** 8周，基于每晚约2小时的投入。
- **核心技术栈:** Go, go-zero, WebSocket, MySQL, Redis, Docker, Kubernetes (GKE), GCP, GitHub Actions。

## 2. 核心原则

- **保持一致:** 每天或每周的持续投入比偶尔的通宵奋战更重要。
- **小步快跑:** 将大任务分解成小块，每周都有可感知的进展。
- **文档驱动:** 在编码前，先用几句话写下你要做什么。随手更新`README.md`。
- **专注MVP:** 严格遵守计划，抵制在核心功能完成前添加“酷炫”功能的诱惑。

## 2.1. 框架选择：Go-Zero vs. Gin (云原生视角)

在启动一个以云原生为目标的项目时，对Web框架的选择至关重要。虽然Gin是一个极其优秀、轻量且高性能的HTTP框架，非常适合快速开发API和Web应用，但本项目选择go-zero是基于更长远的云原生职业发展和项目架构演进的考量。

- **Gin的优势:**
  - **简洁、灵活:** Gin的API设计直观，学习曲线平缓，社区庞大，生态丰富。对于构建单体应用或简单的微服务，它是一个非常高效的选择。
  - **高性能:** 以性能著称，路由速度快，内存占用低。

- **为什么本项目选择Go-Zero:**
  - **原生微服务架构:** Go-zero不仅仅是一个Web框架，它是一个完整的微服务工程化体系。它原生集成了gRPC，并提供了`goctl`工具，可以一键生成API、RPC、数据模型等代码，极大地提升了开发效率并保证了工程规范。这与本项目第二阶段“微服务改造”的目标完全契合。
  - **云原生亲和性:** Go-zero内置了服务注册与发现、负载均衡、熔断、限流、监控等一系列治理功能。这些都是构建一个稳定、可扩展的云原生应用所必需的组件，让你在开发阶段就能接触到生产级的微服务治理实践。
  - **职业发展对齐:** 从职业发展的角度看，掌握Gin能让你成为一个优秀的Go Web开发者。而掌握go-zero，则能让你直接跨入**分布式系统和微服务架构**的领域。你将深入实践gRPC、Protobuf、服务治理等在大型互联网公司中广泛应用的核心技术，这对于冲击高级工程师或架构师岗位具有极高的价值。

**结论:** 对于一个旨在学习和实践云原生部署、微服务架构的现代化后端项目，**go-zero是比Gin更贴合目标的选择**。它虽然初期有一定的学习成本（需要理解RPC、.api和.proto文件），但其带来的工程化优势和对云原生理念的深度实践，将为你的职业生涯提供更强大的助力。

---

## 3. 详细进度表

### **第一阶段: 核心逻辑与本地环境 (Weeks 1-2)**

**目标:** 在本地完成核心游戏引擎的开发，不依赖网络和微服务。

- #### **Week 1: 环境搭建与数据建模**
  - **任务:**
    - [ ] 创建 GitHub 私有仓库 (`project-ace`) 并初始化 Go 项目。
    - [ ] 安装 `go-zero` 工具。
    - [ ] 定义核心数据结构：`Card`, `Deck`, `Player`, `Hand` 等。
    - [ ] 搭建 `docker-compose.yml`，用于启动本地的 MySQL 和 Redis。
  - **产出:** 一个包含核心数据模型和本地开发环境的 Go 项目骨架。

- #### **Week 2: 游戏引擎与牌力算法**
  - **任务:**
    - [ ] 开发并测试牌力判断算法 (`Hand Strength Evaluator`)。
    - [ ] 实现核心牌局状态机（洗牌、发牌、下注、结算）。
    - [ ] 编写一个简单的 `main` 函数，可以在命令行中模拟一局完整的游戏。
  - **产出:** 一个可在本地运行的、功能性的德州扑克游戏逻辑库。

---

### **第二阶段: 微服务改造与网络通信 (Weeks 3-4)**

**目标:** 将单体逻辑拆分为微服务，并通过 WebSocket 实现客户端-服务器交互。

- #### **Week 3: 用户服务与游戏RPC**
  - **任务:**
    - [ ] 使用 `go-zero` 创建 `user-api` 和 `user-rpc`，实现用户注册/登录。
    - [ ] 创建 `game-rpc` 服务，并将上周的游戏引擎逻辑集成进去。
    - [ ] 设计 RPC 接口 (`CreateRoom`, `JoinRoom`, `PerformAction`)。
  - **产出:** 独立的用户服务和游戏核心逻辑服务。

- #### **Week 4: WebSocket网关与本地集成**
  - **任务:**
    - [ ] 创建 `game-api` 服务，管理 WebSocket 连接。
    - [ ] 实现消息转发：`game-api` 接收客户端指令 -> 调用 `game-rpc`。
    - [ ] 实现状态广播：`game-rpc` 状态变更 -> `game-api` 推送给客户端。
    - [ ] 在本地完整启动所有服务，并用测试工具模拟客户端完成一局游戏。
  - **产出:** 一套可以在本地协同工作的微服务。

---

### **第三阶段: 容器化与GCP云基础架构 (Weeks 5-6)**

**目标:** 将应用容器化，并配置好在GCP上运行所需的所有云服务。

- #### **Week 5: 全面容器化与GCP项目设置**
  - **任务:**
    - [ ] 为所有微服务编写 `Dockerfile`。
    - [ ] 创建 GCP 项目，启用所需 API (GKE, Cloud SQL, etc.)。
    - [ ] 安装和配置 `gcloud` CLI。
    - [ ] 创建用于 CI/CD 的服务账号 (Service Account) 并保存密钥。
  - **产出:** 每个服务对应的 Docker 镜像和配置好的 GCP 项目。

- #### **Week 6: 部署云端托管服务**
  - **任务:**
    - [ ] 在 GCP 上创建 **Cloud SQL (MySQL)** 和 **Memorystore (Redis)** 实例。
    - [ ] 创建 **Artifact Registry** 用于托管 Docker 镜像。
    - [ ] 将数据库密码等敏感信息存入 **Secret Manager**。
    - [ ] 修改应用配置以连接到云端服务，构建镜像并推送到 Artifact Registry。
  - **产出:** 运行中的云端数据库/缓存，以及存储在 Artifact Registry 中的应用镜像。

---

### **第四阶段: GKE部署与自动化 (Weeks 7-8)**

**目标:** 将应用部署到 Kubernetes，建立完整的 CI/CD 流水线，并完成项目文档。

- #### **Week 7: Kubernetes 部署与调试**
  - **任务:**
    - [ ] 创建一个 GKE Autopilot 集群。
    - [ ] 编写所有服务的 Kubernetes 部署文件 (`deployment.yaml`, `service.yaml`, `ingress.yaml`)。
    - [ ] 首次将应用手动部署到 GKE (`kubectl apply`)。
    - [ ] 学习使用 `kubectl logs` 和 `kubectl describe` 进行云端调试。
  - **产出:** 一个在 GKE 上成功运行的应用。

- #### **Week 8: CI/CD 自动化与项目收尾**
  - **任务:**
    - [ ] 在 GitHub 仓库中配置 GCP 密钥。
    - [ ] 编写 GitHub Actions (`deploy.yml`) 工作流，实现 `push-to-main` 自动部署。
    - [ ] **编写一份高质量的 `README.md`**，包含项目介绍、架构图和部署指南。
    - [ ] 清理代码，检查并合并所有分支。
  - **产出:** 一个拥有自动化部署能力且文档齐全的高质量项目仓库。
